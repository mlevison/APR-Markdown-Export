---
title: "Misconceptions with Test Driven Development"
date: "2008-11-18"
categories: 
  - "software-development"
tags: 
  - "open-source"
  - "test-driven-development"
  - "yagni"
coverImage: "test-xs.jpg"
excerpt: '- Does TDD really work? I've written about this before: [Advantages of'
---

import Figure from '@/components/global/figure.astro';
import TestXs from 'src/content/blog/misconceptions-with-test-driven-development/images/test-xs.jpg';


<Figure
  src={TestXs}
  alt="a pencil sitting on a test bubble sheet - image licensed from Photodune"
  caption="a pencil sitting on a test bubble sheet - image licensed from Photodune"
/>
 In the past few weeks I've heard several misconceptions raised about Test Driven Development:

- Does TDD really work? I've written about this before: [Advantages of TDD](/blog/advantages-of-tdd "Advantages of TDD"); In addition [George Dinwiddie maintains a list](external:https://biblio.gdinwiddie.com/biblio/StudiesOfTestDrivenDevelopment) of case studies (including one from IBM). Finally Keith Braithwaite has recently done some research on measuring the benefit of TDD. Currently the results are buried in a presentation ([pdf](external:https://www.keithbraithwaite.demon.co.uk/professional/presentations/2008/qcon/MeasureForMeasure.pdf)). Key message: "measuring a over 20 projects: if you have a large number of unit tests your code will be **an order of magnitude** less complex."
- Writing the tests **after** the code has been written is the same as Test Driven Development. Its not, there are significant benefits to TDD that I outlined in: "[Test Driven Development vs Plain Old Unit Testing](/blog/test-driven-dev)".
- TDD isn't useful for helping to design the architecture of programs.

The later is an interesting question. You can find voices on the net that say TDD **by itself** (with no thought given to the architecture is bad). The best example of this is "[Coplien and Martin Debate TDD, CDD and Professionalism](external:https://www.infoq.com/interviews/coplien-martin-tdd/)" (with some excellent comments) and a few blog posts that follow: "[The TDD Controversy - JAOO 2007](external:https://community.ative.dk/blogs/ative/archive/2007/09/28/the-tdd-controversy-jaoo-2007.aspx) " and "[TDD vs good design/architecture principles](external:https://xebia.com/blog/tdd-vs-good-designarchitecture-principles/)" - outline the debate.

If we accept that TDD isn't entirely sufficient for design, then the question becomes how much architecture is required and what would a good project designed with TDD look like?

The real trick is balancing upfront design with the principle of [YAGNI](external:https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it). Since like most developers I'm tempted to over design ("I know I will need this method/class later on"), I force myself to wait until the last responsible moment (typically just before I would need the code) to do my design work (saving a lot of waste - in the form of unused code). In the case of the larger architecture I discourage people from thinking more than one iteration ahead, any further ahead and the requirements are likely change. On rare occasions this means missing a big issue that forces a lot of rework. Since I have a rock solid tests I'm not all that upset and I believe I've still saved a lot of time with the architecture I didn't build.

So if TDD can be used on a large scale and to help drive architecture there must be examples. The leading members of the community (JB Rainsberger, Nat Pryce and Lasse Koskela) all have clients with products built and architected using TDD. Unfortunately these are all closed source or clients that don't want to be talked about publicly.

In the open source world there are a number of applications and libraries developed using TDD:

- Obviously all of the Agile related tools ([JUnit](external:https://sourceforge.net/projects/junit/files/junit/), [NUnit](external:https://nunit.org), [MbUnit](external:https://code.google.com/p/mb-unit/), [Gallio](external:https://www.gallio.org/), [JMock](external:https://jmock.org/repository.html), [RMock](external:https://sourceforge.net/projects/rmock/files/rmock/2.0.0/), [CruiseControl](external:https://cruisecontrol.sourceforge.net/svn.html), [CruiseControl.NET](external:https://confluence.public.thoughtworks.org/display/CCNET/Welcome+to+CruiseControl.NET) and Hudson) were developed using TDD. However this is just a bit self referential
- [Bazaar](external:http://bazaar.canonical.com/en/) - a distributed version control system, used by: LaunchPad, MySQL and Mailman (**Python**)
- [Allelogram](external:https://code.google.com/p/allelogram/) - a program for normalizing and binning microsatellite genotypes. (**Java**)
- [Jena](external:https://jena.sourceforge.net/) - a framework for building [Semantic Web](external:https://www.w3.org/2001/sw/) applications. It provides a programmatic environment for [RDF](external:https://www.w3.org/RDF/), [RDFS](external:https://www.w3.org/TR/rdf-schema/) and [OWL](external:https://www.w3.org/2001/sw/WebOnt/), [SPARQL](external:https://www.w3.org/TR/rdf-sparql-query/) and includes a rule-based inference engine. (**Java**) Related: [Eyeball](external:https://jena.sourceforge.net/Eyeball/) - lint for RDF/OWL
- [Helium](external:https://sourceforge.net/projects/he-project/files/) - (He) is a lightweight and extremely useful templating engine based entirely on XML. He is 100% Java and 100% TDD (Test Driven Development) (**Java**)
- http.net - a dirt simple HTTP server written in C#. It supports minimal functionality and is primarily intended as example code for TDD et al. (**C#)**
- [Joda](external:https://joda-time.sourceforge.net/) - provides a quality replacement for the Java _date_ and _time_ classes. (**Java**)
- Joyent Connector (source) - The Connector suite of applications provide cool features such as search, tagging, and RSS feeds that we believe will make your life easier on a day to day basis. (**ruby**)
- [Task Coach](external:https://www.taskcoach.org/) - a task manager written in **Python**.
- In addition the Google Chrome browser was developed in part with TDD: Chromium has used a combination of test-driven and other development processes. Sometimes we write tests first and then implement features to pass them, sometimes we use existing tests as a guide to what to work on next, and sometimes we implement first and test afterward. It depends on the subject at hand, and on the individual developer.
- [Mark Shuttleworth](external:https://www.markshuttleworth.com/archives/150) remarks TDD is used in developing Ubuntu.

Undoubtedly there are a number of open source projects that are Test Driven, please let me know if you're aware of some I missed. In addition to proving its possible these projects also act as examples as to the sort of architecture that TDD can help build.

Image via: [https://photodune.net/](external:https://photodune.net/)
